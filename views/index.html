<html>
	<head>
		<meta charset=utf-8>
		<title>Tatiana Sutherland</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script src="orbit-controls.js"></script>
		<script src="flips.js"></script>
		<script>

			let renderer
				, scene
				, camera
				, mesh
				, controls

			const init = () => {

				// renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight )
				document.body.appendChild( renderer.domElement )

				// scene
				scene = new THREE.Scene()

				// camera
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )
				camera.position.z = 15
				controls = new THREE.OrbitControls(camera, renderer.domElement)

				// nope, not working
				// var geometry = new THREE.WireframeBufferGeometry()

				// geometry
				var geometry = new THREE.BufferGeometry();

				// duplicate top left and bottom right
				// vertices because each vertex needs to appear once per triangle.
				// vertices must be counter clockwise around serface normal
				var vertices = new Float32Array( [
					-2.75, 2.75,  1.0, //1
					-2.75, 5.5,  1.0,
					-5.5, 5.5,  1.0,

					-5.5, 5.5,  1.0,
					-5.5,  2.75,  1.0,
					-2.75, 2.75,  1.0,

					 0, 5.5, 1.0, //2
					-2.75, 5.5,  1.0,
					-2.75,  2.75,  1.0,

					-2.75,  2.75,  1.0,
					 0,  2.75,  1.0,
					 0, 5.5, 1.0,

					 0, 5.5, 1.0, //3
					 0,  2.75,  1.0,
					 2.75,  2.75,  1.0,

					 2.75,  2.75,  1.0,
					 2.75,  5.5,  1.0,
					 0, 5.5, 1.0,

					 5.5, 5.5, 1.0, //4
					 2.75,  5.5,  1.0,
					 2.75,  2.75,  1.0,

					 2.75,  2.75,  1.0,
					 5.5,  2.75,  1.0,
					 5.5, 5.5, 1.0,

					-2.75,  2.75,  1.0, //5
					-5.5, 2.75, 1.0,
					-5.5,  0,  1.0,

					-5.5,  0,  1.0,
					-2.75,  0,  1.0,
					-2.75,  2.75,  1.0,

					-2.75,  2.75,  1.0, //6
					-2.75, 0, 1.0,
					 0,  0,  1.0,

					 0,  0,  1.0,
					 0,  2.75,  1.0,
					-2.75,  2.75,  1.0,

					 2.75,  2.75,  1.0, //7
					 0, 2.75, 1.0,
					 0,  0,  1.0,

					 0,  0,  1.0,
					 2.75,  0,  1.0,
					 2.75,  2.75,  1.0,

					 2.75,  2.75,  1.0, //8
					 2.75,  0,  1.0,
					 5.5,  0,  1.0,

					 5.5,  0,  1.0,
					 5.5,  2.75,  1.0,
					 2.75,  2.75,  1.0,

					-5.5,  0,  1.0, //9
					-5.5, -2.75, 1.0,
					-2.75, -2.75,  1.0,

					-2.75, -2.75,  1.0,
					-2.75,  0,  1.0,
					-5.5,  0,  1.0,

					 0,  0,  1.0, //10
					-2.75, 0, 1.0,
					-2.75, -2.75,  1.0,

					-2.75, -2.75,  1.0,
					 0, -2.75,  1.0,
					 0,  0,  1.0,

					 0,  0,  1.0, //11
					 0, -2.75, 1.0,
					 2.75, -2.75,  1.0,

					 2.75, -2.75,  1.0,
					 2.75,  0,  1.0,
					 0,  0,  1.0,

					 5.5,  0,  1.0, //12
					 2.75,  0,  1.0,
					 2.75, -2.75,  1.0,

					 2.75, -2.75,  1.0,
					 5.5,  -2.75,  1.0,
					 5.5,  0,  1.0,

					-2.75, -2.75,  1.0, //13
					-5.5, -2.75,  1.0,
					-5.5, -5.5,  1.0,

					-5.5, -5.5,  1.0,
					-2.75, -5.5,  1.0,
				    -2.75, -2.75,  1.0,

					-2.75, -2.75,  1.0, //14
				    -2.75, -5.5,  1.0,
					 0, -5.5, 1.0,

					 0, -5.5, 1.0,
					 0,  -2.75,  1.0,
					-2.75, -2.75,  1.0,

					 2.75, -2.75,  1.0, //15
					 0,  -2.75,  1.0,
					 0, -5.5, 1.0,

					 0, -5.5, 1.0,
					 2.75,  -5.5,  1.0,
					 2.75, -2.75,  1.0,

					 2.75, -2.75,  1.0, //16
					 2.75, -5.5,  1.0,
					 5.5, -5.5, 1.0,

					  5.5, -5.5, 1.0,
					 5.5,  -2.75,  1.0,
					 2.75, -2.75,  1.0,
				])

				var bottomLeftVertices = new Float32Array( [
					-2.75, 2.75,  1.0, //1
					-2.75, 5.5,  1.0,
					-5.5, 5.5,  1.0,

					-5.5, 5.5,  1.0,
					-5.5,  2.75,  1.0,
					-2.75, 2.75,  1.0,

					0, 5.5, 1.0, //2
					-2.75, 5.5,  1.0,
					-2.75,  2.75,  1.0,

					-2.75,  2.75,  1.0,
					0,  2.75,  1.0,
					0, 5.5, 1.0,

					0, 5.5, 1.0, //3
					0,  2.75,  1.0,
					2.75,  2.75,  1.0,

					2.75,  2.75,  1.0,
					2.75,  5.5,  1.0,
					0, 5.5, 1.0,

					5.5, 5.5, 1.0, //4
					2.75,  5.5,  1.0,
					2.75,  2.75,  1.0,

					2.75,  2.75,  1.0,
					5.5,  2.75,  1.0,
					5.5, 5.5, 1.0,

					-2.75,  2.75,  1.0, //5
					-5.5, 2.75, 1.0,
					-5.5,  0,  1.0,

					-5.5,  0,  1.0,
					-2.75,  0,  1.0,
					-2.75,  2.75,  1.0,

					-2.75,  2.75,  1.0, //6
					-2.75, 0, 1.0,
					0,  0,  1.0,

					0,  0,  1.0,
					0,  2.75,  1.0,
					-2.75,  2.75,  1.0,

					2.75,  2.75,  1.0, //7
					0, 2.75, 1.0,
					0,  0,  1.0,

					0,  0,  1.0,
					2.75,  0,  1.0,
					2.75,  2.75,  1.0,

					2.75,  2.75,  1.0, //8
					2.75,  0,  1.0,
					5.5,  0,  1.0,

					5.5,  0,  1.0,
					5.5,  2.75,  1.0,
					2.75,  2.75,  1.0,

					-5.5,  0,  1.0, //9
					-2.75, 0, 1.25,
					-2.75, -2.75,  1.0,

					-2.75, -2.75,  1.0,
					-2.75,  0,  1.0,
					-5.5,  0,  1.0,

					0,  0,  1.0, //10
					-2.75, 0, 1.0,
					-2.75, -2.75,  1.0,

					-2.75, -2.75,  1.0,
					0, -2.75,  1.0,
					0,  0,  1.0,

					0,  0,  1.0, //11
					0, -2.75, 1.0,
					2.75, -2.75,  1.0,

					2.75, -2.75,  1.0,
					2.75,  0,  1.0,
					0,  0,  1.0,

					5.5,  0,  1.0, //12
					2.75,  0,  1.0,
					2.75, -2.75,  1.0,

					2.75, -2.75,  1.0,
					5.5,  -2.75,  1.0,
					5.5,  0,  1.0,

					-2.75, -2.75,  1.0, //13
					-5.5, -2.75,  1.0,
					-5.5, -5.5,  1.0,

					-5.5, -5.5,  1.0,
					-2.75, -5.5,  1.0,
							-2.75, -2.75,  1.0,

					-2.75, -2.75,  1.0, //14
					-2.75, -5.5,  1.0,
					0, -5.5, 1.0,

					0, -5.5, 1.0,
					0,  -2.75,  1.0,
					-2.75, -2.75,  1.0,

					2.75, -2.75,  1.0, //15
					0,  -2.75,  1.0,
					0, -5.5, 1.0,

					0, -5.5, 1.0,
					2.75,  -5.5,  1.0,
					2.75, -2.75,  1.0,

					2.75, -2.75,  1.0, //16
					2.75, -5.5,  1.0,
					5.5, -5.5, 1.0,

						5.5, -5.5, 1.0,
					5.5,  -2.75,  1.0,
					2.75, -2.75,  1.0,
				])

				// attributes
				// itemSize = 3 because there are 3 values (components) per vertex
				geometry.addAttribute( 'position', new THREE.BufferAttribute( bottomLeftVertices, 3 ) );

				material = new THREE.MeshBasicMaterial( { wireframe: true } );

				// const material = new THREE.MeshBasicMaterial( { color: 'white', transparent: true } );

				// const material = new THREE.ShaderMaterial( {
				// 		uniforms: {
				// 				time: { value: 1.0 },
				// 				resolution: { value: new THREE.Vector2() }
				// 		},
				// 		vertexShader: `varying vec4 pos; varying vec2 vuv;
				// 		void main() {
				// 				gl_Position = pos = projectionMatrix * modelViewMatrix * vec4(position,1.0);
				// 				vuv = uv;
				// 		}`
				// ,
				// 		fragmentShader: `varying vec4 pos; varying vec2 vuv;
				// 		void main() {
				// 				vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
				// 				if (abs(mod(vuv.x * 1000.0, 20.0)) < 1.0) {
				// 						color.b = -(vuv.x - 0.9);
				// 						color.r = 0.11;
				// 						color.g = 0.11;
				// 				}
				// 				if (abs(mod(vuv.y * 1000.0, 20.0)) < 1.0) {
				// 						color.b = vuv.y - 0.8;
				// 						color.r = 0.1;
				// 						color.g = 0.1;
				// 				}
				// 				gl_FragColor = color;
				// 		}`
				// } );
				mesh = new THREE.Mesh( geometry, material );
				mesh.material.side = THREE.DoubleSide;

				scene.add( mesh );

			}

			// update positions
			const updatePositions = () => {

				const positions = mesh.geometry.attributes.position.array;

				// setTimeout(() => {
				// 	console.log(':::::::in set setTimeout left:::::')
				// 	flips.topLeftCorner(positions)
				// } , 2000);

				// setTimeout(() => {
				// 	console.log(':::::::in set setTimeout right:::::')
				// 	flips.topRightCorner(positions)
				// } , 3000);

				//helps compare 2 arrays and provides the index and difference
				// rightTopFlipVertices.forEach((vert, idx) =>
				// 	positions[idx] !== vert? console.log('the work for you', idx, vert) : null)

			}

			// render
			const render = () => {

				renderer.render( scene, camera );

			}

			// animate
			const animate = () => {

				requestAnimationFrame( animate );

				//if mouse drag starts in top left corner and ends where x and y are less than start
					//then fold corner
				if ( true ) { // currently true for testing purposes
					updatePositions()
					mesh.geometry.attributes.position.needsUpdate = true; // required after the first render
				}

				controls.update(camera);
				render();

			}

			init()
			animate()

		</script>
	</body>
</html>
