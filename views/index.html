<html>
	<head>
		<meta charset=utf-8>
		<title>Tatiana Sutherland</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script src="orbit-controls.js"></script>
		<script src="flips.js"></script>
		<script>

			let renderer
				, scene
				, camera
				, mesh
				, controls

			const init = () => {

				// renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight )
				document.body.appendChild( renderer.domElement )

				// scene
				scene = new THREE.Scene()

				// camera
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )
				camera.position.z = 15
				controls = new THREE.OrbitControls(camera, renderer.domElement)

				// nope, not working 
				// var geometry = new THREE.WireframeBufferGeometry()
				
				// geometry
				var geometry = new THREE.BufferGeometry();

				// duplicate top left and bottom right
				// vertices because each vertex needs to appear once per triangle.
				// vertices must be counter clockwise around serface normal 
				var vertices = new Float32Array( [
					-2.75, 2.75,  1.0, //1
					-2.75, 5.5,  1.0, 
					-5.5, 5.5,  1.0,

					-5.5, 5.5,  1.0, 
					-5.5,  2.75,  1.0,
					-2.75, 2.75,  1.0, 

					 0, 5.5, 1.0, //2
					-2.75, 5.5,  1.0,
					-2.75,  2.75,  1.0,

					-2.75,  2.75,  1.0,
					 0,  2.75,  1.0,
					 0, 5.5, 1.0,

					 0, 5.5, 1.0, //3
					 0,  2.75,  1.0,
					 2.75,  2.75,  1.0,

					 2.75,  2.75,  1.0,
					 2.75,  5.5,  1.0,
					 0, 5.5, 1.0,

					 5.5, 5.5, 1.0, //4
					 2.75,  5.5,  1.0,
					 2.75,  2.75,  1.0,

					 2.75,  2.75,  1.0,
					 5.5,  2.75,  1.0,
					 5.5, 5.5, 1.0,

					-2.75,  2.75,  1.0, //5
					-5.5, 2.75, 1.0, 
					-5.5,  0,  1.0,

					-5.5,  0,  1.0,
					-2.75,  0,  1.0,
					-2.75,  2.75,  1.0,

					-2.75,  2.75,  1.0, //6
					-2.75, 0, 1.0, 
					 0,  0,  1.0,

					 0,  0,  1.0,
					 0,  2.75,  1.0,
					-2.75,  2.75,  1.0,

					 2.75,  2.75,  1.0, //7
					 0, 2.75, 1.0, 
					 0,  0,  1.0,

					 0,  0,  1.0,
					 2.75,  0,  1.0,
					 2.75,  2.75,  1.0,

					 2.75,  2.75,  1.0, //8
					 2.75,  0,  1.0,
					 5.5,  0,  1.0,

					 5.5,  0,  1.0,
					 5.5,  2.75,  1.0,
					 2.75,  2.75,  1.0,

					-5.5,  0,  1.0, //9
					-5.5, -2.75, 1.0, 
					-2.75, -2.75,  1.0, 

					-2.75, -2.75,  1.0, 
					-2.75,  0,  1.0,
					-5.5,  0,  1.0,

					 0,  0,  1.0, //10
					-2.75, 0, 1.0, 
					-2.75, -2.75,  1.0, 

					-2.75, -2.75,  1.0,
					 0, -2.75,  1.0,
					 0,  0,  1.0,

					 0,  0,  1.0, //11
					 0, -2.75, 1.0, 
					 2.75, -2.75,  1.0, 

					 2.75, -2.75,  1.0, 
					 2.75,  0,  1.0,
					 0,  0,  1.0,

					 5.5,  0,  1.0, //12
					 2.75,  0,  1.0,
					 2.75, -2.75,  1.0, 

					 2.75, -2.75,  1.0,
					 5.5,  -2.75,  1.0,
					 5.5,  0,  1.0,

					-2.75, -2.75,  1.0, //13
					-5.5, -2.75,  1.0,
					-5.5, -5.5,  1.0, 

					-5.5, -5.5,  1.0, 
					-2.75, -5.5,  1.0, 
				    -2.75, -2.75,  1.0, 

					-2.75, -2.75,  1.0, //14
				    -2.75, -5.5,  1.0, 
					 0, -5.5, 1.0,

					 0, -5.5, 1.0,
					 0,  -2.75,  1.0,
					-2.75, -2.75,  1.0,  

					 2.75, -2.75,  1.0, //15
					 0,  -2.75,  1.0,
					 0, -5.5, 1.0, 

					 0, -5.5, 1.0, 
					 2.75,  -5.5,  1.0,
					 2.75, -2.75,  1.0,

					 2.75, -2.75,  1.0, //16
					 2.75, -5.5,  1.0,
					 5.5, -5.5, 1.0, 

					  5.5, -5.5, 1.0, 
					 5.5,  -2.75,  1.0,
					 2.75, -2.75,  1.0,
				])

				// attributes
				// itemSize = 3 because there are 3 values (components) per vertex
				geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

				const material = new THREE.MeshBasicMaterial( { color: 'white', transparent: true } );
				mesh = new THREE.Mesh( geometry, material );
				mesh.material.side = THREE.DoubleSide;

				scene.add( mesh );

			}

			// update positions
			const updatePositions = () => {

				const positions = mesh.geometry.attributes.position.array;

				setTimeout(() => {
					console.log(':::::::in set setTimeout left:::::')
					flips.topLeftCorner(positions)
				} , 2000);

				setTimeout(() => {
					console.log(':::::::in set setTimeout right:::::')
					flips.topRightCorner(positions)
				} , 3000);

				//helps compare 2 arrays and provides the index and difference
				// rightTopFlipVertices.forEach((vert, idx) => 
				// 	positions[idx] !== vert? console.log('the work for you', idx, vert) : null)

			}

			// render
			const render = () => {

				renderer.render( scene, camera );

			}

			// animate
			const animate = () => {

				requestAnimationFrame( animate );

				//if mouse drag starts in top left corner and ends where x and y are less than start 
					//then fold corner
				if ( true ) { // currently true for testing purposes 
					updatePositions()
					mesh.geometry.attributes.position.needsUpdate = true; // required after the first render
				}

				controls.update(camera);
				render();

			}

			init()
			animate()

		</script>
	</body>
</html>